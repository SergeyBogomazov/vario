import matplotlib.pyplot as plt
from math import exp, sin, cos

import numpy as np
'''
данный пакет(или вообще говоря модуль) предназначен для работы с тамики объектами как матрицы вектора итд,
это очень полезно и в целом хорошо, именно поэтому нам понадобиться этот инструмент, так как в задании будет
много работы с так называемыми векторами, то есть математическими объектами представляющими из себя набор
чисел, которые нам нужно будет суммировать и умножать различными способами и именно поэтому и потому что
у нас нет ни сил не желания делать это самостоятельно мы используем уже готовые решения в виде пакетов для питона,
примером которого служит выше импортируемый numpy
'''
from numpy.linalg import linalg
'''
импортируем модуль(пакет) linalg для того чтобы работать с так называемой линейной алгеброй
то есть это означает простыми словами что в будущем нам придётся манипулировать с матрицами,
короче говоря делая это мы получаем инструмент для работы с алгебраическими объектами,
в нашем случае понадобиться решить систему, которую мне лень решать самому, вообще говоря
я уже и забыл как это делается, именно для этого мне и нужет пакет(модуль), который импортируется
в строке выше.
'''
def fdgkxqwejrfhjgfalkjg(wetcwerc, rvttresvgr, brturytub):
    '''
    Эта функия занимается тем что считает то что в функционале к квадрате, так называемая производная
    :param h:
    :param x:
    :param y:
    :return:
    '''
    return ((rvttresvgr-brturytub)/wetcwerc)**2

def aegu9jjssgERHJEOIgore(x, y):
    '''
    Эта функция считает значение функционала
    :param x:
    :param y:
    :return:
    '''

    asghahdgajdkg = 0;
    qwrtyncmq = x[1]-x[0];

    for asdhjhgjfghj in range(len(x)-1):
        asghahdgajdkg += qwrtyncmq*(0.5*(x[asdhjhgjfghj]**2)*fdgkxqwejrfhjgfalkjg(qwrtyncmq,y[asdhjhgjfghj+1],y[asdhjhgjfghj])+(y[asdhjhgjfghj]**2)+y[asdhjhgjfghj]);
    return asghahdgajdkg


def falkjsdhfglaijghflkjgvhepigvujhblirer(n):
    '''
    это функция. она зависит от n, тем самым позволяет нам несколько удобней получать результаты и рисовать графики,
    потому что теперь можно её вызывать когда и где нужно и использовать полученные данные как нам угодно. Вообще говоря
    таким образом получилось немного структурировать код и получить более читаемое решение. Ниже описаны все шаги её создания
    :param n:
    :return:
    '''
    a, b = 0, 1
    '''
    Это концы отрезка, на котором решается задача
    '''
    h = (b - a) / n  # диаметр разбиения
    x = np.linspace(a, b, n + 1)  # равномерно разбитый отрезок [0,1]

    y = np.zeros(n + 1);

    '''
    АНАЛИТИЧЕСКОГО РЕШеНИЯ НЕ БУДЕТ!!!!!!!!!!!!!ПОпроБуйтеРешитьНИчегоНеПолучиться!!11111!!!!11!11!!!!1ЕГО НЕТ!!1!11!1111!!
    Заходит в бар улитка и говорит:

    – Можно виски с колой?

    – Простите, но мы не обслуживаем улиток, – отвечает бармен и вышвыривает ее за дверь.

    Через неделю заходит опять эта улитка и спрашивает:

    – Зачем ты это сделал?
    '''

    y[0] = 0
    y[-1] = 1

    A = np.zeros((n - 1, n + 1))
    '''
    Это матрица. Матрица это набор строк или столбцов, лично мне больше нравиться использовать строки, но в целом сейчас это
    совершенно неважно. Важно отметить что матрица далеко не квадратная. Это означает простыми словами что число строк в ней
    не совпадает с числом столбцов. Такие матрицы вообще говоря неудобный и в целом некрасивые. Но сейчас не об этом. Такой вид
    у матрицы потому, что мы не включили в неё две строки, соответствующие нашим граничным условиям.
    '''
    B = np.ones(n - 1) * h
    '''
    Б это не просто буква - это название столбца свободных элементов. Более того, важно отметить, что такое решение получено
    красивым способом - всего лишь созданием вектора из единиц и умножением на шаг разбиения
    '''

    for i in range(n - 1):
        '''
        В данном цикле происходит заполнение матрицы А. Для крайних случаев происходит проверка, а после выполняется
        отдельный сценарий так как в первой и последней строке всё не так красиво как в остальной матрице. Формулы по 
        которым заполняется матрицы выведена руками на бумаге красной ручкой, потому что чёрная закончилась и тут придётся
        поверить наслово, тем более учитывая что аналитически задача не решается(!!!)
        '''
        if i == 0:
            A[i][i] = ((x[i] ** 2) / h) + ((x[i + 1] ** 2) / h) + 2 * h
            A[i][i + 1] = -1 * ((x[i + 1] ** 2) / h)
        elif i == n - 1:
            A[i][i] = ((x[i] ** 2) / h) + ((x[i + 1] ** 2) / h) + 2 * h
            A[i][i - 1] = -1 * ((x[i - 1] ** 2) / h)
        else:
            A[i][i - 1] = -1 * ((x[i - 1] ** 2) / h)
            A[i][i] = ((x[i] ** 2) / h) + ((x[i + 1] ** 2) / h) + 2 * h
            A[i][i + 1] = -1 * ((x[i + 1] ** 2) / h)

    '''
    Ниже будет произведено вычетание поэлементно. Простыми словами мы возьмём вектора и сначала каждый элемент вектора домножим на число,
    а если конкретней то на граничные условия, а после ещё и точно также поэлементно вычтем
    '''
    B -= A[:, 0] * y[0] - A[:, -1] * y[-1]

    A = A[:, 1:-1]

    y[1:n] = linalg.solve(A, B)
    '''
    На графике было не совсем ясно что происходит, поэтому что это осознать выводим последнюю точку и убеждаемся что
    граничные условия выполняются
    '''
    print(y[-1])
    print(y[0])
    return (x, y)


def aehkgvewrcehwrgcewrghncfewghok(n):
    '''
    Эта функция предназначена для тестирования.
    :param n:
    :return:
    '''
    for arcmoaeitfhqoghijncowxkhjthjr in range(1,n+1):
        fhgfhgfsdgh = falkjsdhfglaijghflkjgvhepigvujhblirer(2**arcmoaeitfhqoghijncowxkhjthjr)
        print("Testing for n= "+str(2**arcmoaeitfhqoghijncowxkhjthjr)+'/. Func[y] = ' + str(aegu9jjssgERHJEOIgore(fhgfhgfsdgh[0],fhgfhgfsdgh[1])))


aehkgvewrcehwrgcewrghncfewghok(10)
'''
Ошибка отрисовки нескольких графиков!!!
'''


y10 = falkjsdhfglaijghflkjgvhepigvujhblirer(10)
y100 = falkjsdhfglaijghflkjgvhepigvujhblirer(100)
y1000 = falkjsdhfglaijghflkjgvhepigvujhblirer(1000)

plt.plot(y10[0], y10[1], 'r')
#plt.plot(y100[0], y100[1], 'y')
#plt.plot(y1000[0], y1000[1], 'g')
plt.show()



